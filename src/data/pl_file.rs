use crate::data::Secret;

use super::{Bundle, Bundles, Secrets, Transient};
use anyhow::{anyhow, Context, Result};
use fd_lock::RwLock;
use sequential::Sequence;
use std::{
    collections::btree_map::Iter,
    fs::{create_dir_all, File, OpenOptions},
    io::{Read, Write as _},
    path::PathBuf,
};

const DOC_FOLDER: &str = if cfg!(test) {
    ".prolock_test"
} else {
    ".prolock"
};
const DOC_FILE: &str = "secrets";
const CURRENT_FORMAT_VERSION: u8 = 0;
const PREFACE: &str = "\
# DO NOT EDIT THIS FILE
#
# For security reasons, prolock verifies the integrity of the readable section
# of this file when decrypting the value of 'secret'.
# Editing any part of this file renders the file unusable for prolock!

";

// Describes the status and content of the prolock file
#[derive(Clone, Debug)]
pub(crate) struct PlFile {
    pub(crate) file_path: PathBuf,
    pub(crate) stored: Stored,
    pub(crate) o_transient: Option<Transient>,
}

// This is the structure that is serialized to the file (after the preface);
// it consists of a readable section and an encrypted section
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct Stored {
    pub(crate) readable: Readable,
    pub(crate) cipher: String,
}

// The readable section is written in clear and also used as auth-tag for the encrypted section
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct Readable {
    pub(crate) header: FileHeader,
    pub(crate) bundles: Bundles,
}

#[derive(Clone, Default, Debug, Serialize, Deserialize)]
pub(crate) struct FileHeader {
    pub(crate) format_version: u8,
    pub(crate) update_counter: Sequence<usize>,
}

impl PlFile {
    pub(crate) fn read_or_create() -> Result<Self> {
        let file_path = document_path()?;
        if file_path.exists() {
            // read file content
            let mut f = RwLock::new(File::open(file_path.clone()).context("opening file")?);
            let mut file_content = String::with_capacity(1024);
            (*f.write().context("locking")?)
                .read_to_string(&mut file_content)
                .context("reading")?;
            let semantic_content = skip_over_comments_and_empty_lines(&file_content);
            Ok(Self {
                file_path,
                o_transient: None,
                stored: serde_json::from_str(semantic_content).context("parsing")?,
            })
        } else {
            // first start: ensure the folder exists and start with empty Self
            create_dir_all(
                file_path
                    .parent()
                    .context("cannot determine folder for storage")?,
            )?;
            Ok(Self {
                file_path,
                o_transient: None,
                stored: Stored {
                    readable: Readable {
                        header: FileHeader {
                            update_counter: Sequence::new(),
                            format_version: CURRENT_FORMAT_VERSION,
                        },
                        bundles: Bundles::new(),
                    },
                    cipher: String::new(),
                },
            })
        }
    }

    pub(crate) fn len(&self) -> usize {
        self.stored.readable.bundles.len()
    }

    pub(crate) fn bundles(&self) -> Iter<'_, String, Bundle> {
        self.stored.readable.bundles.into_iter()
    }

    pub(crate) fn set_password(&mut self, password: String) -> Result<()> {
        if self.stored.cipher.is_empty() {
            self.o_transient = Some(Transient::new(password, Secrets::default()));
        } else {
            self.o_transient = Some(Transient::from_cipher(
                password,
                &self.stored.readable,
                &self.stored.cipher,
            )?);
        };

        Ok(())
    }

    fn add_bundle<S>(&mut self, key: S, bundle: Bundle) -> Result<()>
    where
        S: AsRef<str>,
    {
        if self.stored.readable.bundles.contains_key(key.as_ref()) {
            Err(anyhow!(
                "add_bundle: bundle '{}' exists already",
                key.as_ref()
            ))
        } else {
            match self.o_transient {
                None => Err(anyhow!("Password is not yet provided")),
                Some(ref mut transient) => self.stored.readable.bundles.add(key, bundle, transient),
            }
        }
    }

    pub(crate) fn get_bundle(&self, key: &str) -> Result<Bundle> {
        self.stored
            .readable
            .bundles
            .get(key)
            .cloned()
            .ok_or(anyhow!("get_bundle: bundle '{key}' does not exist"))
    }

    fn modify_bundle(&mut self, key: String, bundle: Bundle) -> Result<()> {
        if self.stored.readable.bundles.contains_key(&key) {
            match self.o_transient {
                None => Err(anyhow!("Password is not yet provided")),
                Some(ref mut transient) => {
                    self.stored.readable.bundles.modify(key, bundle, transient)
                }
            }
        } else {
            Err(anyhow!("modify_bundle: bundle '{key}' does not exist"))
        }
    }

    fn refs(&self, key: &str) -> (Vec<u64>, bool) {
        self.stored
            .readable
            .bundles
            .0
            .get(key)
            .expect("no bundle for key {key}")
            .refs()
    }

    fn save(&mut self) -> Result<()> {
        // FIXME store to file and read back and compare
        //
        // if successful
        //      rename file
        // else (should never happen)
        //      rollback by discarding the new file and re-reading the old file
        match self.o_transient {
            None => Err(anyhow!("save: cannot save because password is not set")),
            Some(ref transient) => {
                if !self.stored.readable.bundles.is_storable() {
                    return Err(anyhow!("save: not all passwords are in correct state"));
                }
                self.stored.readable.header.update_counter.next();
                self.stored.cipher = transient.as_cipher(&self.stored.readable)?;

                // FIXME write to tempfile and rename
                // lock, verify update_counter is not changed, then write
                let mut f = RwLock::new(
                    OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(document_path()?)?,
                );
                let w = &mut (*f.write()?);

                w.write_all(PREFACE.as_bytes())?;
                w.write_all(serde_json::ser::to_string_pretty(&self.stored)?.as_bytes())?;
                w.flush()?;
                Ok(())
            }
        }
    }

    pub(crate) fn save_with_added_bundle(&mut self, name: String, bundle: Bundle) -> Result<()> {
        unimplemented!("FIXME");
        // self.save()?;
    }

    pub(crate) fn save_with_deleted_bundle(&mut self, name: String) -> Result<()> {
        unimplemented!("FIXME");
        // self.save()?;
    }

    pub(crate) fn save_with_updated_bundle(
        &mut self,
        orig_name: String,
        name: String,
        bundle: Bundle,
    ) -> Result<()> {
        if name.is_empty() {
            return Err(anyhow!("internal error: can't save with empty name"));
        }

        if name == orig_name {
            // remember all previously used refs
            let (mut old_refs, found_non_reffed_secrets) = self.refs(&name);
            assert!(
                !found_non_reffed_secrets,
                "internal error: can't save non-reffed Secrets"
            );
            old_refs.sort();

            self.modify_bundle(name, bundle.clone())?;

            // garbage-collect all now redundant secrets
            // - remove from old_refs all refs that are still in bundle
            for (_name, secret) in &bundle.named_secrets {
                if let Secret::Ref(reff) = secret {
                    if let Ok(index) = old_refs.binary_search(&reff) {
                        old_refs.remove(index);
                    }
                }
            }
            // - remove all remaining old_refs from Secrets
            if let Some(transient) = &mut self.o_transient {
                for reff in old_refs {
                    transient.secrets.remove(&reff);
                }
            }
        } else {
            // if name was changed
            //      remember all previously used refs
            //      add the new value to pl_file
            //      remove the previously used key-value pair
            //      make sure all Secrets are Ref'ed
            //      garbage-collect all now redundant secrets
            unimplemented!("bundle name was changed");
        }

        self.save()?;

        Ok(())
    }

    #[cfg(test)]
    pub(crate) fn content_is_equal_to(&self, other: &PlFile) -> bool {
        // TODO does not compare everything, esp. not the secret values!
        self.file_path == other.file_path
            && self
                .stored
                .readable
                .bundles
                .0
                .iter()
                .zip(&other.stored.readable.bundles.0)
                .map(|((s1, b1), (s2, b2))| {
                    *s1 == *s2
                        && b1.description == b2.description
                        && b1.named_secrets.keys().collect::<Vec<&String>>()
                            == b2.named_secrets.keys().collect::<Vec<&String>>()
                })
                .fold(true, |a, b| a && b)
    }

    #[cfg(test)]
    pub(crate) fn print_content(&self, with_transient: bool) -> String {
        use std::fmt::Write as _;
        let spc = |n: usize| -> String { " ".repeat(4 * n) };

        // We skip
        //     self.file_path: PathBuf,
        //     self.stored.cipher: String,
        //     in self.o_transient: Option<Transient>,
        //          transient.storage_password: SecUtf8,
        //          transient.seq_for_secret_refs: Sequence<u64>,
        let mut output = String::with_capacity(1000);

        macro_rules! wrt {
            ($n:expr, $($args:tt)*) => {
                write!(&mut output, "{}", spc($n)).ok();
                writeln!(&mut output, $($args)*).ok();
            };
        }

        let r = &self.stored.readable;
        wrt!(0, "PlFile: {{");
        wrt!(1, "FileHeader: {{");
        wrt!(2, "format_version: {}", &r.header.format_version);
        wrt!(2, "update_counter: {:?}", r.header.update_counter);
        wrt!(1, "}},");
        wrt!(1, "Bundles: ({{");
        for (name, bundle) in &self.stored.readable.bundles.0 {
            wrt!(2, "{:?}: Bundle {{", name);
            wrt!(3, "description: {:?}", bundle.description);
            wrt!(3, "named_secrets: {{");
            if let Some(ref transient) = self.o_transient {
                for (name, secret) in &bundle.named_secrets {
                    wrt!(4, "{}: ({})", name, secret.disclose(transient));
                }
            }
            wrt!(3, "}},");
            wrt!(2, "}},");
        }
        if with_transient {
            if let Some(ref transient) = self.o_transient {
                wrt!(1, "}},");
                wrt!(1, "{}", transient.as_string());
            } else {
                wrt!(1, "}}");
            }
        } else {
            wrt!(1, "}}");
        }
        wrt!(0, "}}");
        output
    }

    pub(crate) fn add_test_bundles(&mut self, modified: bool) -> Result<(), anyhow::Error> {
        self.add_bundle(
            "Bank of North America",
            Bundle::new_with_creds("aaa_dscr", &[("aaa_cn", "aaa_cs")]),
        )?;
        self.add_bundle(
            "Bank of South America",
            Bundle::new_with_creds(
                "http://one_bank.de\n\n\
                Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! \
                Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! \
                Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! \
                Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! \
                Hello world! Hello world! Hello world! Hello world! Hello world! Hello world! \
                Hello world! Hello world! ",
                &[("aaa_cn", "aaa_cs"), ("asdaqweqweqwe", "rtzrtzfhfghgfh")],
            ),
        )?;
        self.add_bundle(
            "ccc",
            Bundle::new_with_creds(
                "ccc_dscr1\n\
                ccc_dscr2\n\
                ccc_dscr3\n\
                ccc_dscr4\n\
                ccc_dscr5",
                &[
                    ("ccc_cn1", "ccc_cs"),
                    ("ccc_cn2", "ccc_cs"),
                    ("ccc_cn3", "ccc_cs"),
                ],
            ),
        )?;
        if modified {
            self.add_bundle("ddd", modified_bundle())?;
        } else {
            self.add_bundle("ddd", unmodified_bundle())?;
        }
        self.add_bundle(
            "eee",
            Bundle::new_with_creds("eee_dscr", &[("eee_cn", "eee_cs")]),
        )?;
        self.add_bundle(
            "fff",
            Bundle::new_with_creds("fff_dscr", &[("fff_cn", "fff_cs")]),
        )?;
        Ok(())
    }
}
fn unmodified_bundle() -> Bundle {
    Bundle::new_with_creds(
        "ddd_dscr",
        &[
            ("ddd_cn1", "ddd_cs"),
            ("ddd_cn2", "ddd_cs"),
            ("ddd_cn3", "ddd_cs"),
        ],
    )
}
fn modified_bundle() -> Bundle {
    Bundle::new_with_creds(
        "modified description",
        &[
            ("ddd_cn1", "ddd_cs1mod"),
            ("ddd_cn3", "ddd_cs"),
            ("ddd_cn4", "ddd_cs4"),
        ],
    )
}

// tests never work with the real file!
// Returns  ~/.prolock/secrets
fn document_path() -> Result<PathBuf> {
    let mut file_path = dirs::home_dir().context("Can't find home directory")?;
    file_path.push(DOC_FOLDER);
    file_path.push(DOC_FILE);
    Ok(file_path)
}

fn skip_over_comments_and_empty_lines(file_content: &str) -> &str {
    let mut start = 0;
    while let Some(next_line_break) = file_content[start..].find('\n') {
        let line = file_content[start..start + next_line_break].trim_start();
        if !line.is_empty() && !line.starts_with('#') {
            break;
        }
        start += next_line_break + 1;
    }
    &file_content[start..]
}

#[cfg(test)]
mod test {
    use crate::data::bundle::Bundle;

    use super::DOC_FOLDER;
    use anyhow::Context;

    #[test]
    fn good_cycle() {
        // ensure that the doc file does not exist (to not get confused with prev test runs)
        let file = super::document_path().unwrap();
        let doc_dir = file.parent().unwrap();
        if doc_dir.exists() {
            assert!(
                doc_dir.ends_with(DOC_FOLDER),
                "doc_dir = {}",
                doc_dir.display()
            );
            std::fs::remove_dir(doc_dir).ok();
        }

        // test open then save
        let mut f = super::PlFile::read_or_create().context("open").unwrap();
        f.set_password("password".to_string()).unwrap();

        let key = format!("dummy{}", f.len());
        let mut bundle = Bundle::new(
            "some longer description\n\
        some longer description\n\
        some longer description\n\
        some longer description\n\
        some longer description\nsome longer description\n"
                .to_string(),
        );
        bundle.add_cred("user1".to_string(), "SeCreT1".to_string());
        bundle.add_cred("user2".to_string(), "SeCreT2".to_string());
        f.add_bundle(&key, bundle).unwrap();
        f.save().context("save").unwrap();
        assert!(file.exists());

        // test open then check creds
        let mut f = super::PlFile::read_or_create().context("open").unwrap();
        f.set_password("password".to_string()).unwrap();
        let transient = f.o_transient.as_ref().unwrap();

        for (_id, bundle) in f.bundles() {
            assert_eq!(bundle.len(), 2);
            assert_eq!(bundle.secret_value("user1", transient), "SeCreT1");
            assert_eq!(bundle.secret_value("user2", transient), "SeCreT2");
        }
    }

    #[test]
    fn test_skip_over_comments_and_empty_lines() {
        assert_eq!(
            super::skip_over_comments_and_empty_lines(
                r"

    # dasdsad
    # dasdsadertdtr
    
       # adasdsad

Hello
world!"
            ),
            "Hello\nworld!"
        );

        assert_eq!(
            super::skip_over_comments_and_empty_lines("Hello\nworld!"),
            "Hello\nworld!"
        );
    }

    use crate::data::{secret::Secret, PlFile};
    const TEST_PASSWORD: &str = "skudfh";

    #[test]
    fn test_modify_bundle() {
        // initialize
        let mut pl_file = PlFile::read_or_create().unwrap();
        pl_file.set_password(TEST_PASSWORD.to_string()).unwrap();

        // load test data
        pl_file.add_test_bundles(false).unwrap();
        let pl_file_clone = pl_file.clone();
        assert!(pl_file.content_is_equal_to(&pl_file_clone));

        let mut bundle = pl_file.get_bundle("ddd").unwrap();
        {
            // modify ddd bundle to have the same content as given by modified_bundle()
            bundle.description = "modified description".to_string();
            *bundle.named_secrets.get_mut("ddd_cn1").unwrap() =
                Secret::New("ddd_cs1mod".to_string());
            bundle.named_secrets.remove("ddd_cn2");
            bundle
                .named_secrets
                .insert("ddd_cn4".to_string(), Secret::New("ddd_cs4".to_string()));
        }
        pl_file.modify_bundle("ddd".to_string(), bundle).unwrap();

        // verify
        let mut pl_file2 = PlFile::read_or_create().unwrap();
        pl_file2.set_password(TEST_PASSWORD.to_string()).unwrap();

        // load test data
        pl_file2.add_test_bundles(true).unwrap();
        if pl_file.print_content(false) != pl_file2.print_content(false) {
            println!(
                "assert_eq failed, left: {}, \nright: {}",
                pl_file.print_content(false),
                pl_file2.print_content(false)
            );
            assert!(false, "Comparison failed");
        }
    }

    #[test]
    fn test_rename_bundle() {
        // initialize
        let mut pl_file = PlFile::read_or_create().unwrap();
        pl_file.set_password(TEST_PASSWORD.to_string()).unwrap();

        // load test data
        pl_file.add_test_bundles(false).unwrap();
        let pl_file_clone = pl_file.clone();
        assert!(pl_file.content_is_equal_to(&pl_file_clone));

        let mut bundle = pl_file.get_bundle("ddd").unwrap();
        {
            // modify ddd bundle to have the same content as given by modified_bundle()
            bundle.description = "modified description".to_string();
            *bundle.named_secrets.get_mut("ddd_cn1").unwrap() =
                Secret::New("ddd_cs1mod".to_string());
            bundle.named_secrets.remove("ddd_cn2");
            bundle
                .named_secrets
                .insert("ddd_cn4".to_string(), Secret::New("ddd_cs4".to_string()));
        }
        pl_file.modify_bundle("ddd".to_string(), bundle).unwrap();

        // verify
        let mut pl_file2 = PlFile::read_or_create().unwrap();
        pl_file2.set_password(TEST_PASSWORD.to_string()).unwrap();

        // load test data
        pl_file2.add_test_bundles(true).unwrap();
        if pl_file.print_content(false) != pl_file2.print_content(false) {
            println!(
                "assert_eq failed, left: {}, \nright: {}",
                pl_file.print_content(false),
                pl_file2.print_content(false)
            );
            assert!(false, "Comparison failed");
        }
    }
}
