use super::{Bundle, Bundles, Secrets, Transient};
use anyhow::{anyhow, Context, Result};
use fd_lock::RwLock;
use sequential::Sequence;
use std::{
    collections::btree_map::Iter,
    fs::{create_dir_all, File, OpenOptions},
    io::{Read, Write},
    path::PathBuf,
};

const DOC_FOLDER: &str = if cfg!(test) {
    ".prolock/test"
} else {
    ".prolock"
};
const DOC_FILE: &str = "secrets";
const CURRENT_FORMAT_VERSION: u8 = 0;
const PREFACE: &str = "\
# DO NOT EDIT THIS FILE
#
# For security reasons, prolock verifies the integrity of the readable section
# of this file when decrypting the value of 'secret'.
# Editing any part of this file renders the file unusable for prolock!

";

// Describes the status and content of the prolock file
#[derive(Clone, Debug)]
pub(crate) struct PlFile {
    pub(crate) file_path: PathBuf,
    pub(crate) stored: Stored,
    pub(crate) o_transient: Option<Transient>,
}

// This is the structure that is serialized to the file (after the preface);
// it consists of a readable section and an encrypted section
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct Stored {
    pub(crate) readable: Readable,
    pub(crate) cipher: String,
}

// The readable section is written in clear and also used as auth-tag for the encrypted section
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct Readable {
    pub(crate) header: FileHeader,
    pub(crate) bundles: Bundles,
}

#[derive(Clone, Default, Debug, Serialize, Deserialize)]
pub(crate) struct FileHeader {
    pub(crate) format_version: u8,
    pub(crate) update_counter: Sequence<usize>,
}

impl PlFile {
    fn new(file_path: PathBuf) -> Self {
        Self {
            file_path,
            o_transient: None,
            stored: Stored {
                readable: Readable {
                    header: FileHeader {
                        update_counter: Sequence::new(),
                        format_version: CURRENT_FORMAT_VERSION,
                    },
                    bundles: Bundles::new(),
                },
                cipher: String::new(),
            },
        }
    }

    pub(crate) fn len(&self) -> usize {
        self.stored.readable.bundles.len()
    }

    pub(crate) fn bundles(&self) -> Iter<'_, String, Bundle> {
        self.stored.readable.bundles.into_iter()
    }
    // read without decrypt
    pub(crate) fn read_or_create() -> Result<Self> {
        let file_path = document_path()?;
        if file_path.exists() {
            // read file content
            let mut f = RwLock::new(File::open(file_path.clone()).context("opening file")?);
            let mut file_content = String::with_capacity(1024);
            (*f.write().context("locking")?)
                .read_to_string(&mut file_content)
                .context("reading")?;
            let semantic_content = skip_over_comments_and_empty_lines(&file_content);
            Ok(Self {
                file_path,
                o_transient: None,
                stored: serde_json::from_str(semantic_content).context("parsing")?,
            })
        } else {
            // first start: ensure the folder exists and start with empty Self
            create_dir_all(
                file_path
                    .parent()
                    .context("cannot determine folder for storage")?,
            )?;
            Ok(Self::new(file_path))
        }
    }

    pub(crate) fn set_password(&mut self, password: String) -> Result<()> {
        if self.stored.cipher.is_empty() {
            self.o_transient = Some(Transient::new(password, Secrets::default()));
        } else {
            self.o_transient = Some(Transient::from_cipher(
                password,
                &self.stored.readable,
                &self.stored.cipher,
            )?);
        };

        Ok(())
    }

    pub(crate) fn add_bundle<S>(&mut self, key: S, bundle: Bundle) -> Result<()>
    where
        S: AsRef<str>,
    {
        if self.stored.readable.bundles.contains_key(key.as_ref()) {
            Err(anyhow!("add_bundle: Bundle exists already"))
        } else {
            match self.o_transient {
                None => Err(anyhow!("Password is not yet provided")),
                Some(ref mut transient) => self.stored.readable.bundles.add(key, bundle, transient),
            }
        }
    }

    pub(crate) fn modify_bundle(&mut self, key: String, bundle: Bundle) -> Result<()> {
        if self.stored.readable.bundles.contains_key(&key) {
            match self.o_transient {
                None => Err(anyhow!("Password is not yet provided")),
                Some(ref mut transient) => {
                    self.stored.readable.bundles.modify(key, bundle, transient)
                }
            }
        } else {
            Err(anyhow!("modify_bundle: Bundle dos not yet exist"))
        }
    }

    pub(crate) fn save(&mut self) -> Result<()> {
        match self.o_transient {
            None => Err(anyhow!("save: cannot save because password is not set")),
            Some(ref transient) => {
                if !self.stored.readable.bundles.is_storable() {
                    return Err(anyhow!("save: not all passwords are in correct state"));
                }
                self.stored.readable.header.update_counter.next();
                self.stored.cipher = transient.as_cipher(&self.stored.readable)?;

                // FIXME write to tempfile and rename
                // lock, verify update_counter is not changed, then write
                let mut f = RwLock::new(
                    OpenOptions::new()
                        .write(true)
                        .create(true)
                        .truncate(true)
                        .open(document_path()?)?,
                );
                let w = &mut (*f.write()?);

                w.write_all(PREFACE.as_bytes())?;
                w.write_all(serde_json::ser::to_string_pretty(&self.stored)?.as_bytes())?;
                w.flush()?;
                Ok(())
            }
        }
    }
}

// Returns  ~/.prolock/secrets
fn document_path() -> Result<PathBuf> {
    let mut file_path = dirs::home_dir().context("Can't find home directory")?;
    file_path.push(DOC_FOLDER);
    file_path.push(DOC_FILE);
    Ok(file_path)
}

fn skip_over_comments_and_empty_lines(file_content: &str) -> &str {
    let mut start = 0;
    while let Some(next_line_break) = file_content[start..].find('\n') {
        let line = file_content[start..start + next_line_break].trim_start();
        if !line.is_empty() && !line.starts_with('#') {
            break;
        }
        start += next_line_break + 1;
    }
    &file_content[start..]
}

#[cfg(test)]
mod test {
    use crate::data::bundle::Bundle;

    use super::DOC_FOLDER;
    use anyhow::Context;

    #[test]
    fn good_cycle() {
        // ensure that the doc file does not exist (to not get confused with prev test runs)
        let file = super::document_path().unwrap();
        let doc_dir = file.parent().unwrap();
        if doc_dir.exists() {
            assert!(
                doc_dir.ends_with(DOC_FOLDER),
                "doc_dir = {}",
                doc_dir.display()
            );
            std::fs::remove_dir(doc_dir).ok();
        }

        // test open then save
        let mut f = super::PlFile::read_or_create().context("open").unwrap();
        f.set_password("password".to_string()).unwrap();

        let key = format!("dummy{}", f.len());
        let mut bundle = Bundle::new(
            "some longer description\n\
        some longer description\n\
        some longer description\n\
        some longer description\n\
        some longer description\nsome longer description\n"
                .to_string(),
        );
        bundle.add_cred("user1".to_string(), "SeCreT1".to_string());
        bundle.add_cred("user2".to_string(), "SeCreT2".to_string());
        f.add_bundle(&key, bundle).unwrap();
        f.save().context("save").unwrap();
        assert!(file.exists());

        // test open then check creds
        let mut f = super::PlFile::read_or_create().context("open").unwrap();
        f.set_password("password".to_string()).unwrap();
        let transient = f.o_transient.as_ref().unwrap();

        for (_id, bundle) in f.bundles() {
            assert_eq!(bundle.len(), 2);
            assert_eq!(bundle.secret("user1", transient), "SeCreT1");
            assert_eq!(bundle.secret("user2", transient), "SeCreT2");
        }
    }

    #[test]
    fn test_skip_over_comments_and_empty_lines() {
        assert_eq!(
            super::skip_over_comments_and_empty_lines(
                r"

    # dasdsad
    # dasdsadertdtr
    
       # adasdsad

Hello
world!"
            ),
            "Hello\nworld!"
        );

        assert_eq!(
            super::skip_over_comments_and_empty_lines("Hello\nworld!"),
            "Hello\nworld!"
        );
    }
}
